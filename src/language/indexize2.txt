import { SourceLocation } from '../client.js';
import { BinarizedProgram } from './binarize.js';
import { BUILT_IN_MAP, BUILT_IN_PRED } from './dusa-builtins.js';
import { FlatPremise, freeVarsFlatPremise } from './flatten.js';
import { Conclusion } from './syntax.js';
import { Pattern } from './terms.js';

export interface IndexedBinaryRuleBase {
  type: string;
  inName: string;
  shared: string[];
  passed: string[];
  introduced: string[];
  outName: string;
  outVars: string[];
}

export interface IndexedLookupRule extends IndexedBinaryRuleBase {
  type: 'IndexedLookup';
  indexName: string;
  indexNum: number; // 0 is the primary index, >0 is for auxillary indexes
}

export interface BuiltinRule extends IndexedBinaryRuleBase {
  type: 'Builtin';
  name: BUILT_IN_PRED;
  args: Pattern[];
  value: Pattern;
}

export interface IndexedReindexRule {
  type: 'Reindex';
  name: string;
  args: Pattern[];
  value: Pattern | null;
  outIndex: string;
  outVars: string[];
}

export interface IndexedConclusionRule {
  type: 'Conclusion';
  inName: string;
  inVars: string[];
  conclusion: Conclusion;
}

export type IndexedRule =
  | IndexedLookupRule
  | BuiltinRule
  | IndexedReindexRule
  | IndexedConclusionRule;

/**
 * Permutes the arguments to introduced predicates so that rules like this:
 *
 *    $path-1 X Y :- $path-0, edge X Y.
 *    $path-2 X Z :- $path-1 X Y, path Y Z.
 *
 * become rules like this, where shared variables appear before unshared variables:
 *
 *    $path-1 Y X :- $path-0, edge X Y.
 *    $path-2 X Z :- $path-1 Y X, path Y Z.
 *
 * Depends on the invariant that every predicate introduced by binarization
 * appears at the conclusion of one rule and the first premise of another rule.
 */
export function permuteIntroduced(program: BinarizedProgram) {
  // Compute necessary permutations
  const permutationMap: Map<string, number[]> = new Map();
  for (const rule of program.rules) {
    if (rule.type === 'Binary') {
      const fvPremise = freeVarsFlatPremise(rule.premise);
      const shared = [];
      const unshared = [];
      for (const [i, x] of rule.inVars.entries()) {
        if (fvPremise.has(x)) {
          shared.push(i);
        } else {
          unshared.push(i);
        }
      }
      permutationMap.set(rule.inName, [...shared, ...unshared]);
    }
  }

  // Apply permutations across program
  const rules = program.rules.map((rule) => {
    rule = { ...rule }; // shallow copy
    let permutation: number[] | undefined;
    if (undefined !== (permutation = permutationMap.get(rule.inName))) {
      rule.inVars = rule.inVars.map((_, i) => rule.inVars[permutation![i]]);
    }
    if (rule.type === 'Binary' && undefined !== (permutation = permutationMap.get(rule.outName))) {
      rule.outVars = rule.outVars.map((_, i) => rule.outVars[permutation![i]]);
    }
    return rule;
  });

  return { ...program, rules };
}

function computeProgramIndices

function isDirectlyUsableAsIndex(premise: FlatPremise, shared: string[], introduced: string[]) {
  const fvList = [...shared, ...introduced];
  for (let i = 0; i < premise.args.length; i++) {
    const arg = premise.args[i];
    if (arg.type !== 'var') return false;
    if (fvList[i] !== arg.name) return false;
  }
  return true;
}

export function indexize(program: BinarizedProgram) {
  const { seeds, forbids, demands } = program;
  const rules: IndexedRule[] = [];
  const auxIndexes = new Map();

  for (const rule of program.rules) {
    if (rule.type === 'Binary') {
      const fvPremise = freeVarsFlatPremise(rule.premise);
      const mid = rule.inVars.findIndex((x) => !fvPremise.has(x));
      const [shared, passed] =
        mid === -1 ? [rule.inVars, []] : [rule.inVars.slice(0, mid), rule.inVars.slice(mid)];
      const introduced = [...fvPremise].filter((x) => !shared.some((y) => x === y));

      if (rule.premise.type === 'builtin') {
        rules.push({
          type: 'Builtin',
          inName: rule.inName,
          name: rule.premise.name,
          args: rule.premise.args,
          value: rule.premise.value,
          outName: rule.outName,
          outVars: rule.outVars,
          shared,
          passed,
          introduced,
        });
      }

      // Can we avoid an index altogether?
      else if (isDirectlyUsableAsIndex(rule.premise, shared, introduced)) {
        rules.push({
          type: 'IndexedLookup',
          inName: rule.inName,
          indexName: rule.premise.name,
          indexNum: 0,
          outName: rule.outName,
          outVars: rule.outVars,
          shared,
          passed,
          introduced,
        });
      }
    } 
    
    // Can't avoid an index (at least without additional work)
    // 
    else {
      rules.push(rule);
    }
  }

  return { seeds, forbids, demands };
}
